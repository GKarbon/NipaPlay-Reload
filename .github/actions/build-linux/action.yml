name: 'Build Linux Packages'
description: '构建 Linux 应用并生成多种格式的安装包'
inputs:
  app-version:
    description: '应用版本号'
    required: true
  arch:
    description: '目标架构'
    required: false
    default: 'amd64'
outputs:
  deb-path:
    description: '生成的 DEB 包路径'
    value: ${{ steps.package.outputs.deb_path }}
  appimage-path:
    description: '生成的 AppImage 路径'
    value: ${{ steps.package.outputs.appimage_path }}
  archive-path:
    description: '生成的 tar.gz 路径'
    value: ${{ steps.package.outputs.archive_path }}
  rpm-path:
    description: '生成的 RPM 包路径'
    value: ${{ steps.package.outputs.rpm_path }}
runs:
  using: 'composite'
  steps:
    - name: Install Linux build dependencies
      shell: bash
      run: |
        sudo apt-get update
        # Install core build dependencies
        sudo apt-get install -y clang cmake ninja-build pkg-config libgtk-3-dev
        # Install mpv dependencies for media_kit (必需，即使系统没有也要安装用于构建)
        sudo apt-get install -y libmpv-dev mpv
        # Install mimalloc for better memory management
        sudo apt-get install -y libmimalloc-dev libmimalloc2.0
        # Install packaging tools
        sudo apt-get install -y fuse libfuse2 libqt5svg5 p7zip-full rpm desktop-file-utils
        # Install additional libs that might be needed
        sudo apt-get install -y libasound2-dev libass-dev libmpv-dev
        # Install keybinder-3.0 for hotkey_manager
        sudo apt-get install -y libkeybinder-3.0-dev

    - name: Build Web and copy assets
      shell: bash
      run: |
        chmod +x build_and_copy_web.sh
        ./build_and_copy_web.sh

    - name: Build Linux
      shell: bash
      run: |
        flutter build linux --release
    
    - name: Linux packaging and cleanup
      id: package
      shell: bash
      run: |
        # Define variables
        APP_NAME="NipaPlay"
        APP_NAME_LOWER="nipaplay"
        VERSION="${{ inputs.app-version }}"
        ARCH="${{ inputs.arch }}"
        BUILD_OUTPUT_DIR="build/linux/x64/release/bundle"
        LINUX_BUILD_DIR="build/linux"
        DEB_PKG_NAME="${APP_NAME}-${VERSION}-Linux-${ARCH}"
        APPIMAGE_NAME="${APP_NAME}-${VERSION}-Linux-${ARCH}.AppImage"
        ARCHIVE_NAME="${APP_NAME}-${VERSION}-Linux-${ARCH}.tar.gz"
        DESKTOP_FILE_NAME="io.github.MCDFsteve.NipaPlay-Reload.desktop"
        ICON_NAME="io.github.MCDFsteve.NipaPlay-Reload.png"
        ICON_SOURCE_PATH="assets/images/logo512.png"
        ASSETS_LINUX_DIR="assets/linux"
        RPM_SPEC_TEMPLATE="${ASSETS_LINUX_DIR}/nipaplay.spec.template"
        RPM_SPEC_FILE="nipaplay.spec"
        RPM_PKG_NAME="${APP_NAME}-${VERSION}-1.${ARCH}.rpm"
        
        echo "--- Starting Packaging ---"
        echo "Version: ${VERSION}, Arch: ${ARCH}"
        echo "Build Output: ${BUILD_OUTPUT_DIR}"
        echo "Linux Build Dir: ${LINUX_BUILD_DIR}"
        
        # --- Create .deb package ---
        echo "--- Creating .deb package ---"
        DEB_ROOT="${LINUX_BUILD_DIR}/${DEB_PKG_NAME}"
        mkdir -p "${DEB_ROOT}/opt/${APP_NAME_LOWER}"
        mkdir -p "${DEB_ROOT}/usr/share/applications"
        mkdir -p "${DEB_ROOT}/usr/share/icons/hicolor/512x512/apps"
        mkdir -p "${DEB_ROOT}/DEBIAN"
        chmod 0755 "${DEB_ROOT}/DEBIAN"
        
        # Copy app files
        echo "Copying application files to ${DEB_ROOT}/opt/${APP_NAME_LOWER}/"
        cp -r "${BUILD_OUTPUT_DIR}/"* "${DEB_ROOT}/opt/${APP_NAME_LOWER}/"
        
        # Copy system libmpv libraries to ensure availability
        echo "Copying system libmpv libraries to ${DEB_ROOT}/opt/${APP_NAME_LOWER}/lib/"
        mkdir -p "${DEB_ROOT}/opt/${APP_NAME_LOWER}/lib"
        # Copy system libmpv and create compatibility symlinks
        find /usr/lib /usr/lib/x86_64-linux-gnu -name "libmpv*.so*" -type f 2>/dev/null | while read mpv_lib; do
          cp "$mpv_lib" "${DEB_ROOT}/opt/${APP_NAME_LOWER}/lib/" 2>/dev/null || true
        done
        # Create compatibility symlinks for libmpv.so.1 if needed
        cd "${DEB_ROOT}/opt/${APP_NAME_LOWER}/lib"
        if [ ! -f "libmpv.so.1" ] && [ -f "libmpv.so.2" ]; then
          ln -sf libmpv.so.2 libmpv.so.1
        fi
        cd - >/dev/null
        
        # Create DEBIAN/control from template
        echo "Creating DEBIAN/control"
        sed -e "s/VERSION_PLACEHOLDER/${VERSION}/g" \
            -e "s/ARCH_PLACEHOLDER/${ARCH}/g" \
            "${ASSETS_LINUX_DIR}/DEBIAN/control.template" > "${DEB_ROOT}/DEBIAN/control"
        
        # Copy postinst/postrm scripts if they exist
        if [ -f "${ASSETS_LINUX_DIR}/DEBIAN/postinst" ]; then
          echo "Copying postinst script"
          cp "${ASSETS_LINUX_DIR}/DEBIAN/postinst" "${DEB_ROOT}/DEBIAN/"
          chmod 0755 "${DEB_ROOT}/DEBIAN/postinst"
        fi
        if [ -f "${ASSETS_LINUX_DIR}/DEBIAN/postrm" ]; then
          echo "Copying postrm script"
          cp "${ASSETS_LINUX_DIR}/DEBIAN/postrm" "${DEB_ROOT}/DEBIAN/"
          chmod 0755 "${DEB_ROOT}/DEBIAN/postrm"
        fi
        
        # Copy desktop file and icon
        echo "Copying desktop file and icon"
        cp "${ASSETS_LINUX_DIR}/${DESKTOP_FILE_NAME}" "${DEB_ROOT}/usr/share/applications/"
        cp "${ICON_SOURCE_PATH}" "${DEB_ROOT}/usr/share/icons/hicolor/512x512/apps/${ICON_NAME}"
        
        # Build the .deb package
        echo "Building .deb package..."
        dpkg-deb --build --root-owner-group "${DEB_ROOT}" "${LINUX_BUILD_DIR}/${DEB_PKG_NAME}.deb"
        echo ".deb package created at ${LINUX_BUILD_DIR}/${DEB_PKG_NAME}.deb"
        
        # --- Create AppImage using linuxdeployqt ---
        echo "--- Creating AppImage ---"
        APPDIR="${LINUX_BUILD_DIR}/${APP_NAME}-AppDir"
        
        mkdir -p "${APPDIR}/lib"
        mkdir -p "${APPDIR}/data"
        
        # Copy main executable to AppDir root
        echo "Copying executable to AppDir root"
        cp "${BUILD_OUTPUT_DIR}/${APP_NAME}" "${APPDIR}/"
        
        # Copy contents of bundle/lib to AppDir/lib
        echo "Copying lib/* to AppDir/lib/"
        cp -r "${BUILD_OUTPUT_DIR}/lib/." "${APPDIR}/lib/"
        
        # Copy contents of bundle/data to AppDir/data
        echo "Copying data/* to AppDir/data/"
        cp -r "${BUILD_OUTPUT_DIR}/data/." "${APPDIR}/data/"
        
        # Copy system libmpv libraries to AppImage
        echo "Copying system libmpv libraries to AppImage"
        find /usr/lib /usr/lib/x86_64-linux-gnu -name "libmpv*.so*" -type f 2>/dev/null | while read mpv_lib; do
          cp "$mpv_lib" "${APPDIR}/lib/" 2>/dev/null || true
        done
        # Create compatibility symlinks for libmpv.so.1 if needed
        cd "${APPDIR}/lib"
        if [ ! -f "libmpv.so.1" ] && [ -f "libmpv.so.2" ]; then
          ln -sf libmpv.so.2 libmpv.so.1
        fi
        cd - >/dev/null
        
        # Copy desktop file and icon to AppDir root
        echo "Copying desktop file and icon to AppDir root"
        cp "${ASSETS_LINUX_DIR}/${DESKTOP_FILE_NAME}" "${APPDIR}/"
        cp "${ICON_SOURCE_PATH}" "${APPDIR}/${ICON_NAME}"
        
        # Download linuxdeployqt
        echo "Downloading linuxdeployqt..."
        wget -q https://github.com/probonopd/linuxdeployqt/releases/download/continuous/linuxdeployqt-continuous-x86_64.AppImage -O linuxdeployqt
        chmod +x linuxdeployqt
        
        # Run linuxdeployqt
        echo "Running linuxdeployqt..."
        export LD_LIBRARY_PATH="${APPDIR}/lib:${LD_LIBRARY_PATH}"
        chmod +x "${APPDIR}/${APP_NAME}"
        
        ./linuxdeployqt "${APPDIR}/${APP_NAME}" -unsupported-allow-new-glibc -appimage -bundle-non-qt-libs
        
        echo "Listing *.AppImage files in current directory after linuxdeployqt:"
        ls -la *.AppImage || echo "No AppImage found in current directory."
        
        # Find and rename the generated AppImage
        echo "Locating and renaming generated AppImage..."
        GENERATED_APPIMAGE=$(find . -maxdepth 1 -name "*.AppImage" -not -name "linuxdeployqt*.AppImage" -print -quit) 
        if [ -n "$GENERATED_APPIMAGE" ]; then
          echo "Found generated AppImage: $GENERATED_APPIMAGE"
          mv "$GENERATED_APPIMAGE" "${LINUX_BUILD_DIR}/${APPIMAGE_NAME}"
          echo "AppImage created at ${LINUX_BUILD_DIR}/${APPIMAGE_NAME}"
        else
          echo "AppImage generation failed or file not found by find command!"
        fi
        rm -f linuxdeployqt # Clean up downloaded tool
        
        # --- Create compressed binary archive (.tar.gz) ---
        echo "--- Creating .tar.gz archive ---"
        ARCHIVE_CONTENT_DIR="${LINUX_BUILD_DIR}/archive_content"
        mkdir -p "${ARCHIVE_CONTENT_DIR}"
        
        # Copy the essential runtime files from the build output
        echo "Copying application files to archive directory"
        cp -r "${BUILD_OUTPUT_DIR}/"* "${ARCHIVE_CONTENT_DIR}/"
        
        # Copy system libmpv libraries to tar.gz archive
        echo "Copying system libmpv libraries to tar.gz archive"
        mkdir -p "${ARCHIVE_CONTENT_DIR}/lib"
        find /usr/lib /usr/lib/x86_64-linux-gnu -name "libmpv*.so*" -type f 2>/dev/null | while read mpv_lib; do
          cp "$mpv_lib" "${ARCHIVE_CONTENT_DIR}/lib/" 2>/dev/null || true
        done
        # Create compatibility symlinks for libmpv.so.1 if needed
        cd "${ARCHIVE_CONTENT_DIR}/lib"
        if [ ! -f "libmpv.so.1" ] && [ -f "libmpv.so.2" ]; then
          ln -sf libmpv.so.2 libmpv.so.1
        fi
        cd - >/dev/null
        
        # Add a simple run script
        RUN_SCRIPT_PATH="${ARCHIVE_CONTENT_DIR}/run.sh"
        echo "Creating run.sh script at ${RUN_SCRIPT_PATH}"
        echo '#!/bin/sh' > "${RUN_SCRIPT_PATH}"
        echo '# Run script for NipaPlay binary archive' >> "${RUN_SCRIPT_PATH}"
        echo 'DIR="$(dirname "$(readlink -f "$0")")"' >> "${RUN_SCRIPT_PATH}"
        echo 'export LD_LIBRARY_PATH="$DIR/lib:$LD_LIBRARY_PATH"' >> "${RUN_SCRIPT_PATH}"
        echo 'export GTK_CSD=0' >> "${RUN_SCRIPT_PATH}"
        echo 'export GTK3_NOCSD=1' >> "${RUN_SCRIPT_PATH}"
        echo '' >> "${RUN_SCRIPT_PATH}"
        echo '# Check for libmpv (required by media_kit)' >> "${RUN_SCRIPT_PATH}"
        echo 'if ! ldconfig -p | grep -q libmpv; then' >> "${RUN_SCRIPT_PATH}"
        echo '  echo "警告: 系统未找到 libmpv 库"' >> "${RUN_SCRIPT_PATH}"
        echo '  echo "NipaPlay 需要 libmpv 支持视频播放"' >> "${RUN_SCRIPT_PATH}"
        echo '  echo "请安装: sudo apt install libmpv1 mpv (Ubuntu/Debian)"' >> "${RUN_SCRIPT_PATH}"
        echo '  echo "或者:   sudo dnf install mpv-libs mpv (Fedora)"' >> "${RUN_SCRIPT_PATH}"
        echo '  echo "或者:   sudo pacman -S mpv (Arch)"' >> "${RUN_SCRIPT_PATH}"
        echo '  echo ""' >> "${RUN_SCRIPT_PATH}"
        echo 'fi' >> "${RUN_SCRIPT_PATH}"
        echo '' >> "${RUN_SCRIPT_PATH}"
        echo '# Print library path for debugging' >> "${RUN_SCRIPT_PATH}"
        echo 'echo "LD_LIBRARY_PATH: $LD_LIBRARY_PATH"' >> "${RUN_SCRIPT_PATH}"
        echo '' >> "${RUN_SCRIPT_PATH}"
        echo '# Execute the main binary' >> "${RUN_SCRIPT_PATH}"
        echo '"$DIR/NipaPlay" "$@"' >> "${RUN_SCRIPT_PATH}"
        chmod +x "${RUN_SCRIPT_PATH}"
        
        # Add an install helper script
        INSTALL_SCRIPT_PATH="${ARCHIVE_CONTENT_DIR}/install-deps.sh"
        echo "Creating install-deps.sh script at ${INSTALL_SCRIPT_PATH}"
        echo '#!/bin/bash' > "${INSTALL_SCRIPT_PATH}"
        echo '# 依赖安装脚本 for NipaPlay' >> "${INSTALL_SCRIPT_PATH}"
        echo '' >> "${INSTALL_SCRIPT_PATH}"
        echo 'echo "NipaPlay 依赖安装助手"' >> "${INSTALL_SCRIPT_PATH}"
        echo 'echo "========================"' >> "${INSTALL_SCRIPT_PATH}"
        echo '' >> "${INSTALL_SCRIPT_PATH}"
        echo '# 检测发行版' >> "${INSTALL_SCRIPT_PATH}"
        echo 'if [ -f /etc/debian_version ]; then' >> "${INSTALL_SCRIPT_PATH}"
        echo '  echo "检测到 Debian/Ubuntu 系统"' >> "${INSTALL_SCRIPT_PATH}"
        echo '  sudo apt update' >> "${INSTALL_SCRIPT_PATH}"
        echo '  sudo apt install -y libmpv1 mpv libgtk-3-0 ffmpeg libass9 libkeybinder-3.0-0' >> "${INSTALL_SCRIPT_PATH}"
        echo 'elif [ -f /etc/fedora-release ]; then' >> "${INSTALL_SCRIPT_PATH}"
        echo '  echo "检测到 Fedora 系统"' >> "${INSTALL_SCRIPT_PATH}"
        echo '  sudo dnf install -y mpv-libs mpv gtk3 ffmpeg libass keybinder3' >> "${INSTALL_SCRIPT_PATH}"
        echo 'elif [ -f /etc/arch-release ]; then' >> "${INSTALL_SCRIPT_PATH}"
        echo '  echo "检测到 Arch Linux 系统"' >> "${INSTALL_SCRIPT_PATH}"
        echo '  sudo pacman -S --needed mpv gtk3 ffmpeg libass libkeybinder3' >> "${INSTALL_SCRIPT_PATH}"
        echo 'else' >> "${INSTALL_SCRIPT_PATH}"
        echo '  echo "未识别的 Linux 发行版"' >> "${INSTALL_SCRIPT_PATH}"
        echo '  echo "请手动安装以下依赖:"' >> "${INSTALL_SCRIPT_PATH}"
        echo '  echo "- libmpv (mpv 媒体播放器库)"' >> "${INSTALL_SCRIPT_PATH}"
        echo '  echo "- gtk3 (GUI 工具包)"' >> "${INSTALL_SCRIPT_PATH}"
        echo '  echo "- ffmpeg (媒体处理)"' >> "${INSTALL_SCRIPT_PATH}"
        echo '  echo "- libass (字幕渲染)"' >> "${INSTALL_SCRIPT_PATH}"
        echo '  echo "- libkeybinder3 (热键绑定)"' >> "${INSTALL_SCRIPT_PATH}"
        echo 'fi' >> "${INSTALL_SCRIPT_PATH}"
        echo '' >> "${INSTALL_SCRIPT_PATH}"
        echo 'echo "依赖安装完成！现在可以运行 ./run.sh 启动 NipaPlay"' >> "${INSTALL_SCRIPT_PATH}"
        chmod +x "${INSTALL_SCRIPT_PATH}"
        
        # Add README file
        README_PATH="${ARCHIVE_CONTENT_DIR}/README-Linux.md"
        echo "Creating README-Linux.md at ${README_PATH}"
        echo '# NipaPlay Linux 版本使用说明' > "${README_PATH}"
        echo '' >> "${README_PATH}"
        echo '## 快速开始' >> "${README_PATH}"
        echo '' >> "${README_PATH}"
        echo '1. **安装依赖**（首次使用必需）：' >> "${README_PATH}"
        echo '   ```bash' >> "${README_PATH}"
        echo '   ./install-deps.sh' >> "${README_PATH}"
        echo '   ```' >> "${README_PATH}"
        echo '' >> "${README_PATH}"
        echo '2. **运行程序**：' >> "${README_PATH}"
        echo '   ```bash' >> "${README_PATH}"
        echo '   ./run.sh' >> "${README_PATH}"
        echo '   ```' >> "${README_PATH}"
        echo '' >> "${README_PATH}"
        echo '## 依赖说明' >> "${README_PATH}"
        echo '' >> "${README_PATH}"
        echo 'NipaPlay 需要以下系统库才能正常运行：' >> "${README_PATH}"
        echo '' >> "${README_PATH}"
        echo '- **libmpv** - 核心视频播放支持（media_kit 需要）' >> "${README_PATH}"
        echo '- **gtk3** - 图形界面' >> "${README_PATH}"
        echo '- **ffmpeg** - 视频解码' >> "${README_PATH}"
        echo '- **libass** - 字幕渲染' >> "${README_PATH}"
        echo '- **libkeybinder3** - 热键绑定' >> "${README_PATH}"
        echo '' >> "${README_PATH}"
        echo '## 手动安装依赖' >> "${README_PATH}"
        echo '' >> "${README_PATH}"
        echo '### Ubuntu/Debian' >> "${README_PATH}"
        echo '```bash' >> "${README_PATH}"
        echo 'sudo apt update' >> "${README_PATH}"
        echo 'sudo apt install libmpv1 mpv libgtk-3-0 ffmpeg libass9 libkeybinder-3.0-0' >> "${README_PATH}"
        echo '```' >> "${README_PATH}"
        echo '' >> "${README_PATH}"
        echo '### Fedora' >> "${README_PATH}"
        echo '```bash' >> "${README_PATH}"
        echo 'sudo dnf install mpv-libs mpv gtk3 ffmpeg libass keybinder3' >> "${README_PATH}"
        echo '```' >> "${README_PATH}"
        echo '' >> "${README_PATH}"
        echo '### Arch Linux' >> "${README_PATH}"
        echo '```bash' >> "${README_PATH}"
        echo 'sudo pacman -S mpv gtk3 ffmpeg libass libkeybinder3' >> "${README_PATH}"
        echo '```' >> "${README_PATH}"
        echo '' >> "${README_PATH}"
        echo '## 故障排除' >> "${README_PATH}"
        echo '' >> "${README_PATH}"
        echo '如果遇到 "Cannot find libmpv" 错误：' >> "${README_PATH}"
        echo '1. 确保已安装 libmpv：`ldconfig -p | grep libmpv`' >> "${README_PATH}"
        echo '2. 如果没有，运行 `./install-deps.sh` 或手动安装上述依赖' >> "${README_PATH}"
        echo '' >> "${README_PATH}"
        echo '如果遇到其他问题，请访问：' >> "${README_PATH}"
        echo 'https://github.com/MCDFsteve/NipaPlay-Reload/issues' >> "${README_PATH}"
        
        # Create the tarball
        echo "Creating tarball..."
        tar -czvf "${LINUX_BUILD_DIR}/${ARCHIVE_NAME}" -C "${ARCHIVE_CONTENT_DIR}" .
        echo ".tar.gz archive created at ${LINUX_BUILD_DIR}/${ARCHIVE_NAME}"
        
        # --- Create RPM package ---
        echo "--- Creating RPM package ---"
        RPM_BUILD_ROOT="${HOME}/rpmbuild"
        mkdir -p "${RPM_BUILD_ROOT}"/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
        
        # Prepare sources for RPM build
        mkdir -p "${RPM_BUILD_ROOT}/SOURCES/bundle"
        cp -r "${BUILD_OUTPUT_DIR}/." "${RPM_BUILD_ROOT}/SOURCES/bundle/"
        cp "${ASSETS_LINUX_DIR}/${DESKTOP_FILE_NAME}" "${RPM_BUILD_ROOT}/SOURCES/"
        cp "${ICON_SOURCE_PATH}" "${RPM_BUILD_ROOT}/SOURCES/logo512.png"
        
        # Prepare spec file
        echo "Preparing RPM spec file..."
        sed -e "s/VERSION_PLACEHOLDER/${VERSION}/g" \
            "${RPM_SPEC_TEMPLATE}" > "${RPM_BUILD_ROOT}/SPECS/${RPM_SPEC_FILE}"
        
        # Build RPM
        echo "Building RPM..."
        rpmbuild -ba "${RPM_BUILD_ROOT}/SPECS/${RPM_SPEC_FILE}" --define "_topdir ${RPM_BUILD_ROOT}" --define "_sourcedir ${RPM_BUILD_ROOT}/SOURCES" --nodeps
        
        # Move the generated RPM to the final artifact directory
        echo "Moving RPM package..."
        RPM_ARCH_DIR="x86_64"
        GENERATED_RPM_PATH=$(find "${RPM_BUILD_ROOT}/RPMS/${RPM_ARCH_DIR}/" -name "nipaplay-${VERSION}*.rpm" -print -quit)
        DESIRED_RPM_NAME="NipaPlay-${VERSION}-Linux-${ARCH}.rpm"
        if [ -n "${GENERATED_RPM_PATH}" ]; then
          mv "${GENERATED_RPM_PATH}" "${LINUX_BUILD_DIR}/${DESIRED_RPM_NAME}"
          echo "RPM package moved and renamed to ${LINUX_BUILD_DIR}/${DESIRED_RPM_NAME}"
        else
          echo "Error: RPM file not found in ${RPM_BUILD_ROOT}/RPMS/${RPM_ARCH_DIR}/"
        fi
        
        # --- Final Check ---
        echo "Checking if all required Linux packages exist..."
        MISSING_FILES=false
        if [ ! -f "${LINUX_BUILD_DIR}/${DEB_PKG_NAME}.deb" ]; then
          echo "Error: .deb file not found! Expected: ${LINUX_BUILD_DIR}/${DEB_PKG_NAME}.deb"
          MISSING_FILES=true
        fi
        if [ ! -f "${LINUX_BUILD_DIR}/${APPIMAGE_NAME}" ]; then
          echo "Error: AppImage file not found! Expected: ${LINUX_BUILD_DIR}/${APPIMAGE_NAME}"
          MISSING_FILES=true
        fi
        if [ ! -f "${LINUX_BUILD_DIR}/${ARCHIVE_NAME}" ]; then
          echo "Error: .tar.gz file not found! Expected: ${LINUX_BUILD_DIR}/${ARCHIVE_NAME}"
          MISSING_FILES=true
        fi
        DESIRED_RPM_NAME_FOR_CHECK="NipaPlay-${VERSION}-Linux-${ARCH}.rpm"
        if [ ! -f "${LINUX_BUILD_DIR}/${DESIRED_RPM_NAME_FOR_CHECK}" ]; then
           echo "Error: RPM file not found! Expected: ${LINUX_BUILD_DIR}/${DESIRED_RPM_NAME_FOR_CHECK}"
           MISSING_FILES=true
        fi

        if [ "$MISSING_FILES" = true ]; then
          echo "One or more package files are missing. Failing the build."
          exit 1
        else
          echo "All required Linux packages found."
        fi

        # --- Cleanup ---
        echo "--- Cleaning up intermediate directories ---"
        rm -rf "${DEB_ROOT}" "${APPDIR}" "${ARCHIVE_CONTENT_DIR}"
        
        echo "--- Linux Packaging Complete ---"
        
        # Set outputs
        echo "deb_path=${LINUX_BUILD_DIR}/${DEB_PKG_NAME}.deb" >> $GITHUB_OUTPUT
        echo "appimage_path=${LINUX_BUILD_DIR}/${APPIMAGE_NAME}" >> $GITHUB_OUTPUT
        echo "archive_path=${LINUX_BUILD_DIR}/${ARCHIVE_NAME}" >> $GITHUB_OUTPUT
        echo "rpm_path=${LINUX_BUILD_DIR}/${DESIRED_RPM_NAME_FOR_CHECK}" >> $GITHUB_OUTPUT
